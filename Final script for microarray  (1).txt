############################################
#
# Title: An end to end workflow for differential gene expression using Affymetrix microarrays
# Workflow documentation can be found at: 
# http://www.bioconductor.org/packages/release/workflows/vignettes/maEndToEnd/inst/doc/MA-Workflow.html
#
# Author: shanzida Siddique (ss51@hood.edu)
# Date: 10/22/19
#
###########################################
# One common command at the start of an R script is:
rm(list=ls())  # Clear R's memory

# Here is where I set working directories etc.  that will change in other script versions

setwd ("/Users/shanzida/Documents/BIFX572 genomics and proteomics /class 10:8")
# print working directory 
getwd()
#------------------------------------------------------
###################################################
# Workflow packages installation from Bioconductor
# These packages are BiocManager,arrays,ArrayTools
if (!requireNamespace("BiocManager", quietly = TRUE))
  install.packages("BiocManager")
BiocManager::install("arrays")
BiocManager::install("ArrayTools")
# I can't install maEndToEnd package because Bioconductor version '3.10' requires R version '3.6'.My R version is 3.8
if (!require("BiocManager"))
  install.packages("BiocManager")
BiocManager::install("maEndToEnd", version = "devel")

## ----biocSetup, include = FALSE, results="hide", warning=FALSE, echo=FALSE----
## Changing the YAML to the following changes the output to 'latex'
## output:
## BiocWorkflowTools::f1000_article
## More at:
## https://stackoverflow.com/questions/35144130/in-knitr-how-can-i-test-for-if-the-output-will-be-pdf-or-word

## add figures to current directory if Rmd is converted to LaTeX
## This simplifies processing on overleaf
if (!is.null(knitr::opts_knit$get("rmarkdown.pandoc.to"))) {
  
  to_html <- knitr::opts_knit$get("rmarkdown.pandoc.to") != 'latex'
  if (!to_html) {
    knitr::opts_chunk$set(fig.path = "", out.width = '.8\\linewidth')
  } 
  
}
## here, pdf specific adapations can be made
## however, the option "rmarkdown.pandoc.to" is only set by rmarkdown::render,
## so it returns NULL if run interactively!


## ----testAlternativeToChunkAbove, eval=FALSE, include=FALSE, echo=FALSE----
#  # this does not work as it will only test the output formats
#  # specified in the YAML header
#  any(grepl("f1000", rmarkdown::all_output_formats(knitr::current_input())))

## ----knitrOptions, include=FALSE----------------------------------------------
library(BiocStyle)
library(knitr)
options(digits = 4, width = 80)
opts_chunk$set(echo = TRUE, 
               tidy = FALSE, 
               include = TRUE,
               dev = c('png'),
               fig.width = 6, fig.height = 3.5,
               comment = '  ', 
               dpi = 300, cache = TRUE,
               fig.pos = "H")


## ----installBioc, eval=FALSE--------------------------------------------------
#  if (!require("BiocManager"))
#      install.packages("BiocManager")
#  BiocManager::install("maEndToEnd", version = "devel")

## ---- echo=TRUE, results="hide", warning=FALSE, eval=FALSE--------------------

############################################################
Package installed from GitHub
-------------------------------
#  
#  #In order to download the package from GitHub, we need the "install_github"
#  #function from the "remotes" package. We download the latest developer
#  #version of "remotes" from GitHub with the devtool::install_github
#  #function; note that this is necessary as the current "remotes" version on
#  #CRAN doesn't allow us to correctly download the "maEndToEnd" package:
#  
#  install.packages("devtools")
#  library(devtools)
#  
#  devtools::install_github("r-lib/remotes")
#  library(remotes)
#  packageVersion("remotes") # has to be 1.1.1.9000 or later
#  
#  remotes::install_github("b-klaus/maEndToEnd", ref="master")
#  

## ----maEndToEndImport---------------------------------------------------------
suppressPackageStartupMessages({library("maEndToEnd")})

## ----pkgList, results="hide"--------------------------------------------------
#General Bioconductor packages
# All general Bioconductor packages are installed here.
library(Biobase)
library(oligoClasses)

# All Annotation and data import packages are installed.
library(ArrayExpress)
library(pd.hugene.1.0.st.v1)
library(hugene10sttranscriptcluster.db)

#Quality control and pre-processing packages
library(oligo)
library(arrayQualityMetrics)

#Analysis and statistics packages
library(limma)
library(topGO)
library(ReactomePA)
library(clusterProfiler)

#Plotting and color options packages
library(gplots)
library(ggplot2)
library(geneplotter)
library(RColorBrewer)
library(pheatmap)

#Formatting/documentation packages
#library(rmarkdown)
#library(BiocStyle)
library(dplyr)
library(tidyr)

#Helpers:
library(stringr)
library(matrixStats)
library(genefilter)
library(openxlsx)
#library(devtools)

##########################################################
Generate folder for raw data 
----------------------------------

## I have generated a FolderForRawData -----------------------------
raw_data_dir <- tempdir()

if (!dir.exists(raw_data_dir)) {
  dir.create(raw_data_dir)
}
## Downloading the raw data from ArrayExpress
# The first step of the analysis is to download the raw data CEL files. 
#These files are produced by the array scanner software and contain the measured probe intensities.
#The data we use have been deposited at ArrayExpress and have the accession code E-MTAB-2967.
## Download MAGE-TAB Files From ArrayExpress In A Specified Directory
##getAE downloads and extracts the MAGE-TAB files from an ArrayExpress dataset.
## ----getDataEBI, eval=TRUE, results='hide', message=FALSE---------------------
anno_AE <- getAE("E-MTAB-2967", path = raw_data_dir, type = "raw")

###############################################################

## Information about the dataset 
-------------------------------------------------
# Each dataset at ArrayExpress is stored according to the MAGE-TAB (MicroArray Gene Expression Tabular) specifications as a collection of tables bundled with the raw data. The MAGE-TAB format specifies up to five different types of files:
  
#Investigation Description Format (IDF)
#Array Design Format (ADF)
#Sample and Data Relationship Format (SDRF)
#raw data files
#processed data files

#the IDF and the SDRF file are important for us.
#The IDF file contains top level information about the experiment including title, description, submitter contact details and protocols.
#The SDRF file contains essential information on the experimental samples, e.g. the experimental group(s) they belong to.

##########################################################
## Making plot with the values 
---------------------------------------
#Genomic data can be very complex, usually consisting of a number of different components, e.g. information on the experimental samples, annotation of genomic features measured as well as the experimental data itself. In Bioconductor, the approach is taken that these components should be stored in a single structure to easily manage the data.

#The package Biobase contains standardized data structures to represent genomic data. The ExpressionSet class is designed to combine several different sources of information (i.e. as contained in the various MAGE-TAB files) into a single convenient structure. An ExpressionSet can be manipulated (e.g., subsetted, copied), and is the input to or output of many Bioconductor functions.
## ----sumexp, fig.cap = "Structure of Bioconductor’s ExpressionSet class.", echo=FALSE, fig.show="asis", fig.width = 7, fig.height = 4.5----
par(mar=c(0,0,0,0))
plot(1,1,xlim=c(0,100),ylim=c(0, 150),bty="n",
     type="n",xlab="",ylab="",xaxt="n",yaxt="n")
# The following codes plots assayData.It is a Expression data from microarray experiments with microarray probes in rows and sample identifiers in columns
polygon(c(50,85,85,50),c(70,70,130,130),col="lightcoral",border=NA)
polygon(c(55, 56, 56, 55),c(70,70,130,130),col=rgb(1,0,0,.5),border=NA)
polygon(c(50,85,85,50),c(118,118,120,120),col=rgb(1,0,0,.5),border=NA)
text(67.5,100,"assay(s)", cex = 1)
text(67.5,90,"e.g. 'exprs'", cex = 1)
# plot microarray probes
polygon(c(45,49,49,45),c(70,70,130,130),col="honeydew2",border=NA)
text(47,100, "microarray probes", srt=90, cex=1)
# Plot sample id 
polygon(c(50,85,85,50),c(131,131,140,140),col="darkseagreen3",border=NA)
text(67.5,135.5,"sample IDs", cex = 1)

# plot feature data.It is a metadata about the features on the chip
#or technology used for the experiment with same rows as assayData by default and freely assignable columns
#further annotations for the features, for example gene annotations from biomedical databases (annotation).
polygon(c(20,40,40,20),c(70,70,130,130),col=rgb(0,0,1,.5),border=NA)
polygon(c(20,40,40,20),c(118,118,120,120),col=rgb(0,0,1,.5),border=NA)
text(30,100,"featureData", cex = 1)
# Plot microarray probes of feature data
polygon(c(15,19,19,15),c(70,70,130,130),col="honeydew2",border=NA)
text(17,100, "microarray probes", srt=90, cex=1)
# plot features
polygon(c(20,40,40,20),c(131,131,140,140),col="bisque3",border=NA)
text(30,135.5,"features", cex = 1)
# plot pheno data .Pheno data is a description of the samples in the experiment with sample identifiers in rows and description elements in columns; holds the content of the SDRF file
polygon(c(50,65, 65, 50),c(55, 55, 0, 0),col=rgb(.5,0,.5,.5),border=NA)
polygon(c(55, 56, 56, 55),c(55, 55, 0, 0),col=rgb(.5,0,.5,.5),border=NA)
text(57.5, 30,"phenoData", cex = 1, srt=270)
# plot sample ids of pheno data
polygon(c(50,65, 65, 50),c(56,56,65,65),col="darkseagreen3",border=NA)
text(57.5,60.5,"sample IDs", cex = 1)

######################################################
getSDRF
------------------------------------------
##The SDRF (Sample and Data Relationship Format) describes
##the sample characteristics and the relationship between 
##samples, arrays, data files etc. 
##The information in the SDRF is organised so that it follows the natural flow of a functional genomics experiment.

# We import the SDRF file with the read.delim function from the raw data folder in order to obtain the sample annotation.
sdrf_location <- file.path(raw_data_dir, "E-MTAB-2967.sdrf.txt")
SDRF <- read.delim(sdrf_location)
# The sample names are given in the column Array.Data.
#File of the SDRF data table and will be used as rownames for the SDRF file.

#  The SDRF table has turned  into an AnnotatedDataFrame from the Biobase package that we will need later to create an ExpressionSet for our data.
rownames(SDRF) <- SDRF$Array.Data.File
SDRF <- AnnotatedDataFrame(SDRF)

##############################################################
Import celfiles
----------------------------------------------------

## ----importCelfiles, results="hide", eval=TRUE, dependson="getSDRF", warning = FALSE----
# We now create the Expression Set object raw_data, which contains array data, pheno data (from the SDRF file) as well as the information of the chip annotation package used.

#The analysis of Affymetrix arrays starts with CEL files. These are the result of the processing of the raw image files using the Affymetrix software and contain estimated probe intensity values. Each CEL file additionally contains some metadata, such as a chip identifier.

#We use the function read.celfiles from the oligo package to import the files:

##Ensure The Truth Of R Expressions
##If any of the expressions (in … or exprs) are not all TRUE, stop is called, producing an error message indicating the first expression which was not (all) true.
##This function is intended for use in regression tests or also argument checking of functions, in particular to make them easier to read.
raw_data <- oligo::read.celfiles(filenames = file.path(raw_data_dir, 
                                                       SDRF$Array.Data.File),
                                 verbose = FALSE, phenoData = SDRF)
stopifnot(validObject(raw_data))
## phenoData
#Retrieve Information On Experimental Phenotypes Recorded In ESet And ExpressionSet-Derived Classes.
#These generic functions access the phenotypic data (e.g., covariates) and meta-data (e.g., descriptions of covariates) associated with an experiment.
# The pData function of the Biobase package directly accesses the phenoData in the ExpressionSet raw_data. With the head() function, we can view the first six lines of the table. We have a look at the columns included and retain only those columns that are related to the experimental factors of interest.

####################################################
##inspectPhenoData, eval=TRUE
--------------------------------------------
head(Biobase::pData(raw_data))
## The package Biobase contains standardized data structures to represent genomic data. The ExpressionSet class is designed to combine several different sources of information (i.e. as contained in the various MAGE-TAB files) into a single convenient structure. An ExpressionSet can be manipulated (e.g., subsetted, copied), and is the input to or output of many Bioconductor functions.
## The columns of interest for us are the following:

#identifiers of the individuals, i.e. columns “Source.Name”, “Characteristics.individual.”
#disease of the individual, i.e. “Factor.Value.disease.”
#mucosa type, i.e. “Factor.Value.phenotype.”
#We now subselect the corresponding columns:
## ----reassignpData, eval=TRUE-------------------------------------------------
Biobase::pData(raw_data) <- Biobase::pData(raw_data)[, c("Source.Name",
                                                         "Characteristics.individual.",
                                                         "Factor.Value.disease.",
                                                         "Factor.Value.phenotype.")]

################################################################

# Quality control of the raw data
----------------------------------------------------
# The first step after the initial data import is the quality control of the data. Here we check for outliers and try to see whether the data clusters as expected, e.g. by the experimental conditions. The expression intensity values are in the assayData sub-object “exprs” and can be accessed by the exprs(raw_data) function. The rows represent the microarray probes, i.e. the single DNA locations on the chip, while the columns represent one microarray, i.e. a sample of inflamed and non-inflamed tissue of every patient, respectively.
## ----inspectAssayData, eval=TRUE----------------------------------------------
Biobase::exprs(raw_data)[1:5, 1:5]

## ----qualityControlRawDataPCA, fig.cap="PCA plot of the log–transformed raw expression data."----
#For quality control, we take the log2 of Biobase::exprs(raw_data), as expression data is commonly analyzed on a logarithmic scale.


exp_raw <- log2(Biobase::exprs(raw_data))
# We then perform a principal component analysis (PCA) and plot it (Figure 2). Every point in the plot represents one sample, with the colour indicating the mucosa type (inflamed vs non-inflamed) and the shape indicating the disease (UC or CD).
PCA_raw <- prcomp(t(exp_raw), scale. = FALSE)
# PCA plot of the log–transformed raw expression data
percentVar <- round(100*PCA_raw$sdev^2/sum(PCA_raw$Steve^2),1)
sd_ratio <- sqrt(percentVar[2] / percentVar[1])

dataGG <- data.frame(PC1 = PCA_raw$x[,1], PC2 = PCA_raw$x[,2],
                     Disease = pData(raw_data)$Factor.Value.disease.,
                     Phenotype = pData(raw_data)$Factor.Value.phenotype.,
                     Individual = pData(raw_data)$Characteristics.individual.)

ggplot(dataGG, aes(PC1, PC2)) +
  geom_point(aes(shape = Disease, colour = Phenotype)) +
  ggtitle("PCA plot of the log-transformed raw expression data") +
  xlab(paste0("PC1, VarExp: ", percentVar[1], "%")) +
  ylab(paste0("PC2, VarExp: ", percentVar[2], "%")) +
  theme(plot.title = element_text(hjust = 0.5))+
  coord_fixed(ratio = sd_ratio) +
  scale_shape_manual(values = c(4,15)) + 
  scale_color_manual(values = c("darkorange2", "dodgerblue4"))

## ----qualityControlRawDataBox, fig.cap="Intensity boxplots of the log2–transformed raw data."----
# We also represent the probe intensities via a boxplot graph with one box per individual microarray.The oligo::boxplot function, i.e. the boxplot function of the oligo package, can take expression sets as argument. It accesses the expression data and performs a log2-transformation by default. We therefore can use raw_data as argument here.
oligo::boxplot(raw_data, target = "core", 
               main = "Boxplot of log2-intensitites for the raw data")
##This package generates microarray quality metrics reports for data in Bioconductor microarray data containers (ExpressionSet, NChannelSet, AffyBatch). One and two color array platforms are supported.

####################################################################
## ----arrayQualityMetricsRaw, eval = TRUE, warning=FALSE, message=FALSE
---------------------------------------------------------------------

#we have only performed a very basic quality control; more elaborate quality control plots are available in the package arrayQualityMetrics. The package produces an html report, containing the quality control plots together with a description of their aims and an identification of possible outliers. 
arrayQualityMetrics(expressionset = raw_data,
                    outdir = tempdir(),
                    force = TRUE, do.logtransform = TRUE,
                    intgroup = c("Factor.Value.disease.", "Factor.Value.phenotype."))

## ----annotationDataBaseContent, eval = TRUE-----------------------------------
# After normalization, summarization is necessary to be done because on the Affymetrix platform, transcripts are represented by multiple probes, that is multiple locations on the array. For each gene, the background-adjusted and normalized intensities of all probes need to be summarized into one quantity that estimates an amount proportional to the amount of RNA transcript.

#After the summarization step, the summarized data can be annotated with various information, e.g. gene symbols and ENSEMBL gene identifiers. There is an annotation database available from Bioconductor for our platform, namely the package hugene10sttranscriptcluster.db.
head(ls("package:hugene10sttranscriptcluster.db"))

## ----DifferenceBetweenExonAndGeneTypeArrays, fig.width=7, fig.height=6, echo=FALSE, fig.cap="Visualization of the difference between \"Exon\" type array (left) and \"Gene\" type array (right)."----
library(grid)

par(mar=c(0,0,0,0))
plot(1,1,xlim=c(0,100),ylim=c(0, 20),bty="n",
     type="n",xlab="",ylab="",xaxt="n",yaxt="n")
dat <- data.frame(x = rep(seq(0, 2.9, 0.1), 30), 
                  y = rep(seq(0, 2.9, 0.1), each = 30))


col <- c("blue", "darkslategray1", "goldenrod1", "yellow", "royalblue1", "coral")
dat$colours<-sample(rep(col, 150))
dat$colours2 <- sample(c(rep("yellow", 2), rep("goldenrod1", 5), rep("coral",7), 
                         rep("blue", 5), rep ("darkslategray1",3), rep("royalblue1", 8), rep(gray(0:9/10), 87)))
################################################################
# opening the graphic device and  setting up a viewport with borders:
vp1 <- viewport(x = 0.1, y = 0.1, w = 0.12, h = 0.12, 
                just = c("left", "bottom"), name = "vp1")


# plotting rectangles using x/y positions
grid.rect(x=dat$x,y=dat$y, height=0.1, width=0.1, hjust=0,vjust=0,vp=vp1,
          gp=gpar(col=1, fill=as.character(dat$colours)))


vp2 <- viewport(x = 0.5, y = 0.1, w = 0.12, h = 0.12,
                just = c("left", "bottom"), name = "vp1")

#################################################################
# plotting rectangles using x/y positions
grid.rect(x=dat$x,y=dat$y, height=0.1, width=0.1, hjust=0,vjust=0,vp=vp2,
          gp=gpar(col=1, fill=as.character(dat$colours2)))

## ----RMAcalibrationForRLE, eval=TRUE------------------------------------------
palmieri_eset <- oligo::rma(raw_data, target = "core", normalize = FALSE)

## ----boxplotDataForRLETidy, fig.cap="Box-plot for the RLE values", warning=FALSE----
row_medians_assayData <- 
  Biobase::rowMedians(as.matrix(Biobase::exprs(palmieri_eset)))

RLE_data <- sweep(Biobase::exprs(palmieri_eset), 1, row_medians_assayData)

RLE_data <- as.data.frame(RLE_data)
RLE_data_gathered <- 
  tidyr::gather(RLE_data, patient_array, log2_expression_deviation)

ggplot2::ggplot(RLE_data_gathered, aes(patient_array,
                                       log2_expression_deviation)) + 
  geom_boxplot(outlier.shape = NA) + 
  ylim(c(-2, 2)) + 
  theme(axis.text.x = element_text(colour = "aquamarine4", 
                                   angle = 60, size = 6.5, hjust = 1 ,
                                   face = "bold"))
#######################################################################3
## ----RMAcalibrationWITHnormalization, eval=TRUE-------------------------------
## The oligo package: a tool for low-level analysis of oligonucleotide
palmieri_eset_norm <- oligo::rma(raw_data, target = "core")

## ----PCAMetricsCalibrated, fig.cap = "PCA plot of the calibrated, summarized data.", eval = TRUE----
## Performs a principal components analysis on the given data matrix and returns the results as an object of class prcomp.
exp_palmieri <- Biobase::exprs(palmieri_eset_norm)
PCA <- prcomp(t(exp_palmieri), scale = FALSE)

percentVar <- round(100*PCA$sdev^2/sum(PCA$sdev^2),1)
sd_ratio <- sqrt(percentVar[2] / percentVar[1])

dataGG <- data.frame(PC1 = PCA$x[,1], PC2 = PCA$x[,2],
                     Disease = 
                       Biobase::pData(palmieri_eset_norm)$Factor.Value.disease.,
                     Phenotype = 
                       Biobase::pData(palmieri_eset_norm)$Factor.Value.phenotype.)


ggplot(dataGG, aes(PC1, PC2)) +
  geom_point(aes(shape = Disease, colour = Phenotype)) +
  ggtitle("PCA plot of the calibrated, summarized data") +
  xlab(paste0("PC1, VarExp: ", percentVar[1], "%")) +
  ylab(paste0("PC2, VarExp: ", percentVar[2], "%")) +
  theme(plot.title = element_text(hjust = 0.5)) +
  coord_fixed(ratio = sd_ratio) +
  scale_shape_manual(values = c(4,15)) + 
  scale_color_manual(values = c("darkorange2", "dodgerblue4"))

## ----rownamesForHeatmap, fig.height = 8.5, fig.width = 7, eval = TRUE, echo=TRUE----
phenotype_names <- ifelse(str_detect(pData
                                     (palmieri_eset_norm)$Factor.Value.phenotype.,
                                     "non"), "non_infl.", "infl.")

disease_names <- ifelse(str_detect(pData
                                   (palmieri_eset_norm)$Factor.Value.disease.,
                                   "Crohn"), "CD", "UC")

annotation_for_heatmap <- 
  data.frame(Phenotype = phenotype_names,  Disease = disease_names)

row.names(annotation_for_heatmap) <- row.names(pData(palmieri_eset_norm))


## ----HeatmapWithAnnotation, fig.height = 8.5, fig.width = 7, fig.cap="Heatmap of the sample-to-sample distances"----
dists <- as.matrix(dist(t(exp_palmieri), method = "manhattan"))

rownames(dists) <- row.names(pData(palmieri_eset_norm))
hmcol <- rev(colorRampPalette(RColorBrewer::brewer.pal(9, "YlOrRd"))(255))
colnames(dists) <- NULL
diag(dists) <- NA

ann_colors <- list(
  Phenotype = c(non_infl. = "chartreuse4", infl. = "burlywood3"),
  Disease = c(CD = "blue4", UC = "cadetblue2")
)
pheatmap(dists, col = (hmcol), 
         annotation_row = annotation_for_heatmap,
         annotation_colors = ann_colors,
         legend = TRUE, 
         treeheight_row = 0,
         legend_breaks = c(min(dists, na.rm = TRUE), 
                           max(dists, na.rm = TRUE)), 
         legend_labels = (c("small distance", "large distance")),
         main = "Clustering heatmap for the calibrated samples")

###################################################
## Filtering based on intensity
---------------------------------------------------
## ----IntensityBasedManualFiltering, fig.cap="Histogram of the median intensities per gene"----
# For intensity-based filtering, we calculate the row-wise medians from the expression data, as they represent the transcript medians, and assign them to palmieri_medians. From this we create a histogram:
palmieri_medians <- rowMedians(Biobase::exprs(palmieri_eset_norm))

hist_res <- hist(palmieri_medians, 100, col = "cornsilk1", freq = FALSE, 
                 main = "Histogram of the median intensities", 
                 border = "antiquewhite4",
                 xlab = "Median intensities")

## ----setManualThreshold, fig.cap="Histogram of the median intensities per gene with manual intensity filtering threshold (red line)."----
#  In order to infer a cutoff from the data, we inspect the histogram: We visually set a cutoff line man_threshold to the left of the histogram peak in order not to exclude too many genes. In our example, we choose a threshold of 4. We plot the same histogram as before and add the threshold line with the abline() function:

man_threshold <- 4

hist_res <- hist(palmieri_medians, 100, col = "cornsilk", freq = FALSE, 
                 main = "Histogram of the median intensities",
                 border = "antiquewhite4",
                 xlab = "Median intensities")

abline(v = man_threshold, col = "coral4", lwd = 2)

## ----expGroups, dependson="PCAMetricsCalibrated"------------------------------
no_of_samples <- 
  table(paste0(pData(palmieri_eset_norm)$Factor.Value.disease., "_", 
               pData(palmieri_eset_norm)$Factor.Value.phenotype.))
no_of_samples 

## ----filteringOfLowIntensity_transcripts--------------------------------------
samples_cutoff <- min(no_of_samples)

idx_man_threshold <- apply(Biobase::exprs(palmieri_eset_norm), 1,
                           function(x){
                             sum(x > man_threshold) >= samples_cutoff})
table(idx_man_threshold)

palmieri_manfiltered <- subset(palmieri_eset_norm, idx_man_threshold)

################################################################
## Annotation of the transcript clusters
---------------------------------------------------------
## ----annotateData, eval=TRUE, dependson="intensityBasedFiltering", message = FALSE----
# Before we continue with the linear models for microarrays and differential expression, we first add “feature data”, i.e. annotation information to the transcript cluster identifiers stored in the featureData of our ExpressionSet:

anno_palmieri <- AnnotationDbi::select(hugene10sttranscriptcluster.db,
                                       keys = (featureNames(palmieri_manfiltered)),
                                       columns = c("SYMBOL", "GENENAME"),
                                       keytype = "PROBEID")
# We used the function select from AnnotationDbi to query the gene symbols and associated short descriptions for the transcript clusters. For each cluster, we added the gene symbol (SYMBOL) and a short description of the gene the cluster represents (GENENAME).

anno_palmieri <- subset(anno_palmieri, !is.na(SYMBOL))

##############################################################
# Removing multiple mappings
----------------------------------------------
# Many transcript-cluster identifiers will map to multiple gene symbols, i.e. they can’t be unambigously assigned.

# We compute a summary table in the code below to see how many there are:
## ----multipleMappings, dependson="annotateData"-------------------------------
#First, we grouped anno_palmieri by their PROBEID; that way, the subsequent operations are not carried through for each single row, but for each group, i.e. each PROBEID. We then summarized the groups and indicate the number of different genes assigned to a transcript cluster in the column no_of_matches. Finally, we filtered for PROBEIDs with multiple matches, i.e. no_of_matches > 1.

#With dim(probe_stats), we could see how many probes have been mapped to multiple genes.

anno_grouped <- group_by(anno_palmieri, PROBEID)
anno_summarized <- 
  dplyr::summarize(anno_grouped, no_of_matches = n_distinct(SYMBOL))

head(anno_summarized)

anno_filtered <- filter(anno_summarized, no_of_matches > 1)

head(anno_filtered)

probe_stats <- anno_filtered 

nrow(probe_stats)

## ----excludeMultipleMappingsFromAssayData, dependson="multipleMappings"-------
# We want to remove those probe IDs that match the ones in probe_stats, as those are the probes with multiple mappings. We assign these IDs to the variable ids_to_exclude. Then, we generate palmier_final, an expression set without the ids_to_exclude.
ids_to_exlude <- (featureNames(palmieri_manfiltered) %in% probe_stats$PROBEID)

table(ids_to_exlude)

palmieri_final <- subset(palmieri_manfiltered, !ids_to_exlude)

validObject(palmieri_final)

## ----recallAnnoPalmieri-------------------------------------------------------
head(anno_palmieri)

## ----excludeMultipleMappingsFromFeatureData-----------------------------------
# we generate a column PROBEID in fData(palmieri_final) and assign the row names of fData(palmieri_final) to it:
fData(palmieri_final)$PROBEID <- rownames(fData(palmieri_final))

###########################################################

excludeMultipleMappingsFromFeatureData2----------------------------------
# we left-join fData(palmieri_final)with anno_palmieri, which already contains the columns “SYMBOL” and “GENENAME”. A left-join keeps the rows and columns of the first argument and adds the corresponding column entries of the second argument:
fData(palmieri_final) <- left_join(fData(palmieri_final), anno_palmieri)


# restore rownames after left_join
rownames(fData(palmieri_final)) <- fData(palmieri_final)$PROBEID 

validObject(palmieri_final)

##############################################
introduction of Abbreviations
----------------------------------------------
# For the subsequent linear modelling of the data, we introduce the abbreviations “UC” and “CD” for the disease types, and “non_infl.” and “infl.” for the phenotypes, respectively:
individual <- 
  as.character(Biobase::pData(palmieri_final)$Characteristics.individual.)

tissue <- str_replace_all(Biobase::pData(palmieri_final)$Factor.Value.phenotype.,
                          " ", "_")

tissue <- ifelse(tissue == "non-inflamed_colonic_mucosa",
                 "nI", "I")

disease <- 
  str_replace_all(Biobase::pData(palmieri_final)$Factor.Value.disease.,
                  " ", "_")
disease <- 
  ifelse(str_detect(Biobase::pData(palmieri_final)$Factor.Value.disease., 
                    "Crohn"), "CD", "UC")
#########################################################
## createDesign, eval=TRUE, dependson="excludeMultipleMappings"
----------------------------------------------------------
# we create two design matrices, one for each of the two diseases as we will analyze them separately in order to follow the analysis strategy of the original paper closely (one could also fit a joint model to the complete data set; however, the two diseases might show very different characteristics so that a joint fit might not be appropriate).
i_CD <- individual[disease == "CD"]
design_palmieri_CD <- model.matrix(~ 0 + tissue[disease == "CD"] + i_CD)
colnames(design_palmieri_CD)[1:2] <- c("I", "nI")
rownames(design_palmieri_CD) <- i_CD 

i_UC <- individual[disease == "UC"]
design_palmieri_UC <- model.matrix(~ 0 + tissue[disease == "UC"] + i_UC )
colnames(design_palmieri_UC)[1:2] <- c("I", "nI")
rownames(design_palmieri_UC) <- i_UC 

##########################################################
## inspectDesignMatrix, eval = TRUE, dependson="createDesign"
---------------------------------------------------------
head(design_palmieri_CD[, 1:6])

head(design_palmieri_UC[, 1:6])
#########################################################

## visualizeExpressionChanges, fig.cap="Visualization of expression changes"
----------------------------------------------------------------
# Analysis of differential expression based on a single gene
# For linear model fitting and subsequent testing for differential expression by t-test, we will pick the gene with the PROBEID 8164535. It has the gene symbol CRAT and will be named as such in the following code.
# Before fitting the linear model, we have a look at the expression intensities of this gene for each patient in non-inflamed and inflamed tissue, respectively:
tissue_CD <- tissue[disease == "CD"]
crat_expr <- Biobase::exprs(palmieri_final)["8164535", disease == "CD"]
crat_data <- as.data.frame(crat_expr)
colnames(crat_data)[1] <- "org_value"
# compute the variable coefficients by fitting a linear model. We get a vector crat_coef with one entry for each variable.

crat_data <- mutate(crat_data, individual = i_CD, tissue_CD)

crat_data$tissue_CD <- factor(crat_data$tissue_CD, levels = c("nI", "I"))

ggplot(data = crat_data, aes(x = tissue_CD, y = org_value, 
                             group = individual, color = individual)) +
  geom_line() +
  ggtitle("Expression changes for the CRAT gene")

#############################################
obtainFitCRAT
------------------------------------------------------------
crat_coef <- lmFit(palmieri_final[,disease == "CD"],
                   design = design_palmieri_CD)$coefficients["8164535",]

crat_coef

# in order to  obtain the expression values fitted by the model, we multiply the design matrix with this vector of coefficients crat_coef:
crat_fitted <- design_palmieri_CD %*% crat_coef
rownames(crat_fitted) <- names(crat_expr)
colnames(crat_fitted) <- "fitted_value"

crat_fitted

##################################################################
#visualize the difference between non-inflamed and inflamed tissue again after fitting:
-----------------------------------------------------------------
crat_data$fitted_value <- crat_fitted

ggplot(data = 
         crat_data, aes(x = tissue_CD, y = fitted_value, 
                             group = individual, color = individual)) +
  geom_line() +
  ggtitle("Fitted expression changes for the CRAT gene")

############################################################
tTest
--------------------------------------------------------------------
# conduct the t-test on the linear model in order to find out whether the difference between non-inflamed and inflamed tissue differs significantly from 0:
crat_noninflamed <- na.exclude(crat_data$org_value[tissue == "nI"])
crat_inflamed <- na.exclude(crat_data$org_value[tissue == "I"])
res_t <- t.test(crat_noninflamed ,crat_inflamed , paired = TRUE)
res_t

## ----createContrastMatrixAndFitModel, eval=TRUE, dependson="createDesign"-----
##########################################################

# Contrasts and hypotheses tests
---------------------------------------------------------
# We now fit a linear model to our data and apply the contrasts.fit() function to it in order to find genes with significant differential expression between non-inflamed and inflamed tissue:

contrast_matrix_CD <- makeContrasts(I-nI, levels = design_palmieri_CD)

palmieri_fit_CD <- eBayes(contrasts.fit(lmFit(palmieri_final[,disease == "CD"],
                                              design = design_palmieri_CD),
                                        contrast_matrix_CD))

contrast_matrix_UC <- makeContrasts(I-nI, levels = design_palmieri_UC)

palmieri_fit_UC <- eBayes(contrasts.fit(lmFit(palmieri_final[,disease == "UC"],
                                              design = design_palmieri_UC),
                                        contrast_matrix_UC))

########################################################
extractResultsCD, eval = TRUE, dependson="createContrastMatrixAndFitModel", message=FALSE, fig.cap="Histogram of the p–values for Crohn’s disease."----
# Extracting results
---------------------------------------------------------------
# we extract the number of differentially expressed genes. Results can be extracted by use of the topTable function. We extract the results for both Crohn’s disease and ulcerative colitis, and the results are sorted by their absolute t-statistics. As a diagnostic check, we also plot the p-value histogram: We expect a uniform distribution for the p-values that correspond to true null hypotheses, while a peak near zero shows an enrichment for low p-values corresponding to differentially expressed (DE) genes.

table_CD <- topTable(palmieri_fit_CD, number = Inf)
head(table_CD)

hist(table_CD$P.Value, col = brewer.pal(3, name = "Set2")[1],
     main = "inflamed vs non-inflamed - Crohn's disease", xlab = "p-values")


## ----extractResultsUC, eval = TRUE, dependson="createContrastMatrixAndFitModel", message=FALSE, fig.cap="Histogram of the p–values for ulcerative colitis."----

table_UC <- topTable(palmieri_fit_UC, number = Inf)
head(table_UC)

hist(table_UC$P.Value, col = brewer.pal(3, name = "Set2")[2],
     main = "inflamed vs non-inflamed - Ulcerative colitis", xlab = "p-values")

#############################################################
pCutForCD
----------------------------------------------------------------
# Multiple testing FDR, and comparison with results from the original paper
# a p-value of 0.001 was used as a significance cutoff. Using this we get 947 genes identified as differentially expressed for UC:
nrow(subset(table_UC, P.Value < 0.001))

############################################
FDRforUC
-----------------------------------------------------------------
# we can see a clear peak in the p-value histogram (Figure 13), caused by the differentially expressed genes. There we expect the actual FDR of our list to be lower.

# The FDR at a given cutoff is given by the “adjusted” p-value in the results table.
tail(subset(table_UC, P.Value < 0.001))

##########################################
#compareDEgenes, dependson=c("extractResultsUC", "extractResultsCD")
-----------------------------------------------------------------------
# We also calculate the total number of diffentially expressed genes that we find in our workflow analysis.
fpath <- system.file("extdata", "palmieri_DE_res.xlsx", package = "maEndToEnd")
palmieri_DE_res <- sapply(1:4, function(i) read.xlsx(cols = 1, fpath, 
                                                     sheet = i, startRow = 4))

names(palmieri_DE_res) <- c("CD_UP", "CD_DOWN", "UC_UP", "UC_DOWN")
palmieri_DE_res <- lapply(palmieri_DE_res, as.character)
paper_DE_genes_CD <- Reduce("c", palmieri_DE_res[1:2])
paper_DE_genes_UC <- Reduce("c", palmieri_DE_res[3:4])

overlap_CD <- length(intersect(subset(table_CD, P.Value < 0.001)$SYMBOL,  
                               paper_DE_genes_CD)) / length(paper_DE_genes_CD)


overlap_UC <- length(intersect(subset(table_UC, P.Value < 0.001)$SYMBOL,
                               paper_DE_genes_UC)) / length(paper_DE_genes_UC)
overlap_CD
overlap_UC 

total_genenumber_CD <- length(subset(table_CD, P.Value < 0.001)$SYMBOL)
total_genenumber_UC <- length(subset(table_UC, P.Value < 0.001)$SYMBOL)

total_genenumber_CD
total_genenumber_UC

###############################################################
# Visualization of DE analysis results - volcano plot
-------------------------------------------------------------
## ----VolcanoPlot, fig.cap="Volcano plot of the DE-genes", fig.height=8, fig.width=7----
# For a visualization of the differentially expressed genes, we create a volcano plot, which is commonly used to summarize the results of a differential expression analysis in a single figure.

# For a better overview, we only show gene symbols of genes with a fold change greater than 1, which we define in the volcano_names object. The highlight option in the volcanoplot function is set to 100 and thus only labels the 100 genes with the lowest p-values.
volcano_names <- ifelse(abs(palmieri_fit_CD$coefficients)>=1, 
                        palmieri_fit_CD$genes$SYMBOL, NA)


volcanoplot(palmieri_fit_CD, coef = 1L, style = "p-value", highlight = 100, 
            names = volcano_names,
            xlab = "Log2 Fold Change", ylab = NULL, pch=16, cex=0.35)
#######################################################

#Gene ontology (GO) based enrichment analysis
-----------------------------------------------------------
## FDRcontrolledDEgenes, dependson=c("extractResultsUC", "extractResultsCD"), eval=TRUE----
# we create tables with differentially expressed genes for CD and UC, respectively, and choose an FDR cutoff of 10%. Here, we focus on the CD subset of the data.
DE_genes_CD <- subset(table_CD, adj.P.Val < 0.1)$PROBEID
# Matching the background set of genes
# The function genefinder from the genefilter package will be used to find a background set of genes that are similar in expression to the differentially expressed genes.
#########################################################
## GOAnalysisCreateBackgrounds, eval=TRUE, warning=FALSE, message=FALSE-----
# For every differentially expressed gene, we try to find genes with similar expression with genefinder. The genefinder function returns a list with two elements for each gene: one with the indices of the background genes found and one with the distances to the DE-genes:
back_genes_idx <- genefilter::genefinder(palmieri_final, 
                                         as.character(DE_genes_CD), 
                                         method = "manhattan", scale = "none")

#############################################################
## GOAnalysisCreateBackgrounds2, eval=TRUE, warning=FALSE, message=FALSE----
-------------------------------------------------------------------
# We have to extract the PROBEIDs, which correspond to the indices. We do that by using the sapply function, which gives us a single matrix with the DE-genes as column names and the PROBEIDs of the corresponding background genes in the cells below:
back_genes_idx <- sapply(back_genes_idx, function(x)x$indices)

## ----GOAnalysisCreateBackgrounds3, eval=TRUE, warning=FALSE, message=FALSE----
# We then create a vector back_genes containing all background gene PROBEIDs:

#In order to eliminate foreground genes, i.e. DE-genes, from the back_genes set, we use the setdiff function. It returns all elements from the first argument (back_genes) that are not part of the second argument (DE_genes_CD). With the intersect function, we verify that we were successful: it should return 0, as there shouldn’t be any intersect anymore between back_genesand DE_genes_CD:
back_genes <- featureNames(palmieri_final)[back_genes_idx]
back_genes <- setdiff(back_genes, DE_genes_CD)


intersect(back_genes, DE_genes_CD)
length(back_genes)
######################################################################
## multidensityPlot, fig.cap="Selecting a background set of genes for the gene ontology analysis."
-----------------------------------------------------------------
# We create a multidensity plot with mean expression on the x-axis and curves for all genes, foreground genes and background genes, respectively (Figure 15). We want to see whether the background genes show a plot similar to the foreground genes so that the background is not biased for the gene enrichment analysis:
multidensity(list(
  all = table_CD[,"AveExpr"] ,
  fore = table_CD[DE_genes_CD , "AveExpr"],
  back = table_CD[rownames(table_CD) %in% back_genes, "AveExpr"]),
  col = c("#e46981", "#ae7ee2", "#a7ad4a"),
  xlab = "mean expression",
  main = "DE genes for CD-background-matching")
#Running topGO
########################################################
## ----createFactorOfInterestingGenes, dependson="GOAnalysisCreateBackgrounds", eval=TRUE----
--------------------------------------------------------------
# topGO requires a topGOdata object containing the necessary information for the analysis. We follow the steps described in the topGO vignettes: First, we will create a named vector all_genes with all genes to be analyzed, i.e. DE-genes and background genes:
gene_IDs <- rownames(table_CD)
in_universe <- gene_IDs %in% c(DE_genes_CD, back_genes)
in_selection <- gene_IDs %in% DE_genes_CD 
# we created an in_universe vector by using the %in% matching function. We want to know which elements from gene_IDs are also contained in DE_genes_CD and back_genes, as the latter two are our gene universe we use for enrichment analysis. We got a vector in_universe with the length of gene_IDs that has the entry TRUE when the corresponding gene in gene_IDs could be also found in DE_genes_CD or back_genes, and FALSE otherwise.

all_genes <- in_selection[in_universe]
# We did the same for our DE-genes and call this vector in_selection.
all_genes <- factor(as.integer(in_selection[in_universe]))
# We created the all_genes vector: a) First, we selected all the elements from in_selection that are TRUE in in_universe by applying all_genes <- in_selection[in_universe]. b) Then, we converted the elements in all_genes from TRUE and FALSE to 0 and 1 by converting the vector to an integer vector. This way, each element in the vector is a 0 if the corresponding gene is a background gene and a 1 if the corresponding gene is a DE-gene. Also, we converted the vector to a factor. c) We named the vector elements with the corresponding gene_IDs.
names(all_genes) <- gene_IDs[in_universe] 

## ----createTopGODataSet, dependson="createFactorOfInterestingGenes", eval=TRUE, message = FALSE, warning=FALSE----
# We now initialize the topGO data set, using the GO annotations contained in the annotation data base for the chip we are using. The nodeSize parameter specifies a minimum size of a GO category we want to use: i.e. here, categories with less than 10 genes are not included in the testing.
top_GO_data <- new("topGOdata", ontology = "BP", allGenes = all_genes,
                   nodeSize = 10, annot = annFUN.db, affyLib = "hugene10sttranscriptcluster.db")

## ----runtopGOTests, results='hide', eval=TRUE, dependson = "createTopGODataSet", message = FALSE----
# The algorithm starts processing the nodes / GO categories from the highest (bottommost) level and then iteratively moves to nodes from a lower level. If a node is scored as significant, all of its genes are marked as removed in all ancestor nodes. This way, the “elim” algorithm aims at finding the most specific node for every gene.

# The test uses a 0.01 p-value cutoff by default.
result_top_GO_elim <- 
  runTest(top_GO_data, algorithm = "elim", statistic = "Fisher")
result_top_GO_classic <- 
  runTest(top_GO_data, algorithm = "classic", statistic = "Fisher")

## ----processtopGOResults, eval=TRUE, dependson="runtopGOTests"----------------
# We can now inspect the results. We look at the top 100 GO categories according to the “Fisher elim” algorithm. The function GenTable produces a table of significant GO categories, the function printGenes gives genes annotated to them; the significant ones are denoted with a “2” in the “raw p-value” column, the non-significant ones with a “1”. We therefore select raw p-value == 2.

#Note that we do not get the actual p-values here because our all_genes vector doesn’t contain this information; it only tells us whether a gene is differentially expressed or not.

res_top_GO <- GenTable(top_GO_data, Fisher.elim = result_top_GO_elim,
                       Fisher.classic = result_top_GO_classic,
                       orderBy = "Fisher.elim" , topNodes = 100)

genes_top_GO <- printGenes(top_GO_data, whichTerms = res_top_GO$GO.ID,
                           chip = "hugene10sttranscriptcluster.db", geneCutOff = 1000)

res_top_GO$sig_genes <- sapply(genes_top_GO, function(x){
  str_c(paste0(x[x$'raw p-value' == 2, "Symbol.id"],";"), 
        collapse = "")
})

head(res_top_GO[,1:8], 20)
###############################################################
# Visualization of the GO-analysis results
----------------------------------------------------------
# we visualize the three most significant nodes according to the Fisher elim algorithm in the context of the GO hierarchy.
## ----graphOfResults, fig.height = 6, eval=TRUE, results='hide', dpi=600, fig.cap="Significantly enriched GO nodes in the GO hierarchy"----
showSigOfNodes(top_GO_data, score(result_top_GO_elim), firstSigNodes = 3,
               useInfo = 'def')
## A pathway enrichment analysis using reactome
#The package ReactomePA offers the possibility to test enrichment of specific pathways using the free, open-source, curated and peer reviewed Reactome pathway database (24,25). The package requires entrez identifiers, so we convert our PROBEIDs (transcript cluster identifiers) to entrez identifiers using the function mapIDs from the package AnnotationDbi. This will create a named vector that maps the PROBEIDs to the entrez ones, with the PROBEIDs as names and the entrez ids as vector elements.
## ----mapIDsToEntrez, dependson="createFactorOfInterestingGenes", message = FALSE----
entrez_ids <- mapIds(hugene10sttranscriptcluster.db, 
                     keys = rownames(table_CD), 
                     keytype = "PROBEID",
                     column = "ENTREZID")

## ----runReactomeEnrichment, fig.cap="Enriched Reactome pathways and their p–values as a bar chart.", eval = TRUE, warning=FALSE----
# We can now run the enrichment analysis that performs a statistical test based on the hypergeoemtric distribution that is the same as a one sided Fisher-test, which topGO calls “Fisher-classic”.

reactome_enrich <- enrichPathway(gene = entrez_ids[DE_genes_CD], 
                                 universe = entrez_ids[c(DE_genes_CD, 
                                                         back_genes)],
                                 organism = "human",
                                 pvalueCutoff = 0.05,
                                 qvalueCutoff = 0.9, 
                                 readable = TRUE)

reactome_enrich@result$Description <- paste0(str_sub(
  reactome_enrich@result$Description, 1, 20),
  "...")

head(as.data.frame(reactome_enrich))[1:6]
# Visualizing the reactome based analysis results
#The top pathways can be displayed as a bar chart that displays all categories with a p-value below the specified cutoff 
## ----reactomeBar, dependson="runReactomeEnrichment", fig.cap="Enriched Reactome pathways and their p–values as a bar chart."----
barplot(reactome_enrich)

## ----emapplot, dependson="runReactomeEnrichment", fig.width=6, fig.height = 7, fig.cap="Enriched Reactome pathways enrichment results as a graph."----
# The “enrichment map” from the package enrichplot displays the results of the enrichment analysis as a graph, where the color represents the p-value of the pathway and the edge-thickness (that is the line connecting two pathways) is proportional to the number of overlapping genes between two pathways.
emapplot(reactome_enrich, showCategory = 10)

#####################################################
## Session Information 
--------------------------------------
# As the last part of this document, we call the function sessionInfo, which reports the version numbers of R and all the packages used in this session-----------------------------------------------------------------------------
gc()

length(getLoadedDLLs())

sessionInfo()


